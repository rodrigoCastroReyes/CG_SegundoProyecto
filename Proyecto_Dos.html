<!DOCTYPE html>
<html>

<head>
    <title>Computer Graphics</title>
    <script type="text/javascript" src="lib_three/build/three.min.js"></script>
    <script type="text/javascript" src="lib_three/src/loaders/JSONLoader.js"> </script>
    <script type="text/javascript" src="lib_three/examples/js/controls/TrackballControls.js"> </script>
    
    <script type="text/javascript" src="jquery-1.9.0.js"></script>
    <script type="text/javascript" src="lib_three/examples/js/libs/dat.gui.min.js"></script>
    <script type="text/javascript" src="lib_three/examples/js/libs/stats.min.js"></script>
    <style>
        body{
            /* set margin to 0 and overflow to hidden, to go fullscreen */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>

<div id="Stats-output"></div>
<!-- Div which will hold the Output -->
<div id="WebGL-output"></div>
<!-- Javascript code that runs our Three.js examples -->
<script type="text/javascript">

    // once everything is loaded, we run our Three.js stuff.
    $(function () {

        var stats = initStats();

        // create a scene, that will hold all our elements such as objects, cameras and lights.
        var scene = new THREE.Scene();

        // create a render and set the size
        var renderer = new THREE.WebGLRenderer();

        var orbita=0;
        renderer.setClearColorHex(0xCEE3F6, 1.0);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMapEnabled = true;

        var objects=[];

        // create the ground plane
        planeWidth=70;
        planeHeight=60;
        var planeGeometry = new THREE.PlaneGeometry(planeWidth,planeHeight,1,1);
        // PlaneGeometry(width, height, widthSegments, heightSegments) widthSegments y heightSegments son parametros opcionales y son 1 por defecto
        var planeMaterial =    new THREE.MeshLambertMaterial({color: 0xffffff});
        var plane = new THREE.Mesh(planeGeometry,planeMaterial);
        plane.receiveShadow  = true;

        // rotacion y posicion del plano
        plane.rotation.x=-0.5*Math.PI;
        plane.position.x=5;
        plane.position.y=0
        plane.position.z=0
        // se añade el plano a la escena
        scene.add(plane);

        //Ejes auxiliares         
        var axes = new THREE.AxisHelper( 20 );
        scene.add(axes);
        //Cubo
        var cubeGeometry = new THREE.CubeGeometry(4,4,4);
        var cubeMaterialFlatShanding = new THREE.MeshLambertMaterial({color: 0xff0000,shading:THREE.FlatShading });
        var cubeMaterialGShading= new THREE.MeshLambertMaterial({color: 0xeeeeaa});//falta definir gourand shading
        var cubeMaterialPhongShading= new THREE.MeshLambertMaterial({color: 0xffff00});//falta definir phong shading
        var cube = new THREE.Mesh(cubeGeometry, cubeMaterialFlatShanding);
        // posicion del cubo
        cube.position.x=6;
        cube.position.y=5;
        cube.position.z=25;
        var rotateCube=false;
        cube.callback = function() { rotateCube=true }
        // se añade el cubo a la escena
        scene.add(cube);
        objects.push(cube);
        
        //Toroide
        var torusGeometry=new THREE.TorusGeometry(2,1,7,20,Math.Pi*2);
        // TorusGeometry(radius, tube, radialSegments, tubularSegments, arc) 
        var torusMaterial=new THREE.MeshLambertMaterial({color: 0xffff00,shading:THREE.FlatShading });// tipo de material del toroide
        var torusMaterialGShading=new THREE.MeshLambertMaterial({color: 0xeeeeaa});//falta
        var torusMaterialPhongShading=new THREE.MeshLambertMaterial({color: 0xffff00});//falta
        var torus=new THREE.Mesh(torusGeometry,torusMaterial);//se construye el toroide
        //posiciones del toroide 
        torus.position.x=-20;
        torus.position.y=10;
        torus.position.z=-20;
        var rotateTorus=false;
        torus.callback = function() { rotateTorus=true }
        scene.add(torus);//se añade el toroide a la escena
        objects.push(torus);

        var pyramidGeometry=new THREE.CylinderGeometry(0,5,8,4);
        /* CylinderGeometry(radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded) 
            height: altura de la piramide
            radiusSegments: numero de segmentos que se usara para formar las caras superior e inferior, 4 para que la base sea un cuadrado
            heightSegments 1 por defecto
            openEnded: indica si los extremos del cilindo estan abiertos(true) o cubiertos(false), false por defecto
        */
        
        var pyramidMaterial=new THREE.MeshLambertMaterial({color: 0x2ef72e,shading:THREE.FlatShading}); //tipo de material de la piramide
        var pyramidMaterialGShading=new THREE.MeshLambertMaterial({color: 0xffffff});//falta
        var pyramidMaterialPhongShading=new THREE.MeshLambertMaterial({color: 0xffee00});


        var pyramid=new THREE.Mesh(pyramidGeometry,pyramidMaterial);//se construye la piramide
        //posiciones de la piramide 
        pyramid.position.x=20;
        pyramid.position.y=12;
        pyramid.position.z=0;
        scene.add(pyramid); //se añade la piramide a la escena 
        var rotatePyramid=false;
        pyramid.callback = function() { rotatePyramid=true }      
        objects.push(pyramid);

        var radius_sphera=3;//radio de la esfera
        var sphereGeometry = new THREE.SphereGeometry(radius_sphera,15,15);
        sphereGeometry.dinamic=true;
        var sphereMaterial = new THREE.MeshLambertMaterial({color: 0x7777ff,emissive:0x00000,shading:THREE.FlatShading });

        var sphereMaterialGShading=new THREE.MeshLambertMaterial({color: 0xeeeeaa});//falta
       // var sphereMaterialPhongShading=new THREE.MeshLambertMaterial({color: 0xffee00});

        var sphereMaterialPhongShading= new THREE.MeshPhongMaterial({
                    specular: '#a9fcff',
                    color: '#00abb1',
                    emissive: '#006063',
                    shading: THREE.SmoothShading,
                    shininess: 100 
        });

       // sphereGeometry.dynamic=true;
        var sphere = new THREE.Mesh(sphereGeometry,sphereMaterial);
        // posicion de la esfera
        sphere.position.x=0;
        sphere.position.y=14;
        sphere.position.z=20;
        var rotateSphere=false;
        sphere.callback = function() { rotateSphere=true }
        // se añade la esfera a la escena
        scene.add(sphere);         
        objects.push(sphere);
        //camara
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000 );
        camera.position.x= -30;
        camera.position.y=  40; 
        camera.position.z= 30;
        camera.lookAt(scene.position);
        scene.add(camera);

        // add the output of the renderer to the html element
        $("#WebGL-output").append(renderer.domElement);
        
        //Tetera
       var jsonLoader=new THREE.JSONLoader();
       jsonLoader.load("teapot.js", function(geometry) { 
                var material    = new THREE.MeshLambertMaterial({color: 0x660066},shading=THREE.FlatShading); 
                var teapot    = new THREE.Mesh( geometry, material ); 
                teapot.position.x= 0;
                teapot.position.y=0;
                teapot.position.z=0;
                teapot.scale.set(2,2,2);
                scene.add(teapot); 
        });

        //se inicializan las luces y se añaden a la escena
        var spotLight1 = new THREE.SpotLight( 0xffffff );
        spotLight1.position.set( -window.innerWidth/2,window.innerHeight/2,20 );
        scene.add( spotLight1 );
 
        var spotLight2 = new THREE.SpotLight( 0xffffff );
        spotLight2.position.set( -window.innerWidth/2, -window.innerHeight/2,20 );
        scene.add( spotLight2 );
 
        var spotLight3 = new THREE.SpotLight( 0xffffff );
        spotLight3.position.set( window.innerWidth/2, window.innerHeight/2,20 );
        scene.add( spotLight3 );
 
        var spotLight4 = new THREE.SpotLight( 0xffffff );
        spotLight4.position.set( window.innerWidth/2, -window.innerHeight/2,20 );
        scene.add( spotLight4 );

        //Se inicializan los controles de la escena
        var  gui=new dat.GUI();
        
        //controles de la Velocidad de los objetos
        var controlSpeed;//controlador de velocidades
        var speeds;//velocdiades de los objetos
        initSpeeds();// se inicializa la interfaz para el control de la velocidad de los objetos
        
        //controles de los shading
        var view=this;
        var controlShading;//controlador de shading
        view.FlatShading=true;
        view.GouraudShading=false;
        view.PhongShading=false;
        
        initShading();// se inicializa la interfaz para el control de los shadings


        view.StopObjects=false;// control de la detencion de los objetos
        gui.add(view,'StopObjects');

        var orbita_cube=0;
        var orbita_torus=0.02;
        var orbita_pyramid=0.01;
        var orbita_sphere=0.02;
        //movimiento de la camara
        var  controls=new THREE.TrackballControls( camera, renderer.domElement );

         if(view.PhongShading){
            controls.rotateSpeed = 1.0;
            controls.zoomSpeed = 1.2;
            controls.panSpeed = 0.2;
            controls.noZoom = false;
            controls.noPan = false;
        }
        
       
        render();
       
       //control de la velocidad de los objetos
        function  initSpeeds(){
            //controles de las velocidades de los objetos
            speeds=new function(){
                this.cubeSpeed=0.01;
                this.torusSpeed=0.02;
                this.pyramidSpeed=0.02;
                this.sphereSpeed=0.02;
            }

            controlSpeed=gui.addFolder("Speeds of objects");
            controlSpeed.add(speeds,"cubeSpeed",0,0.5);
            controlSpeed.add(speeds,"torusSpeed",0.02,0.5);
            controlSpeed.add(speeds,"pyramidSpeed",0.01,0.5);
            controlSpeed.add(speeds,"sphereSpeed",0.02,0.5);

            controlSpeed.open();
        }

        //control de los shading
        function initShading(){
            controlShading=gui.addFolder("Shadings");

            controlShading.add(view,'FlatShading').listen().onChange(function(value){
                if(value){
                    view.GouraudShading=false;
                    view.PhongShading=false;
                    cube.material=cubeMaterialFlatShanding;
                    torus.material=torusMaterial;
                    pyramid.material=pyramidMaterial;
                    sphere.material=sphereMaterial;
                }
            });

            controlShading.add(view,'GouraudShading').listen().onChange(function(value){
                if(value){
                    view.FlatShading=false;
                    view.PhongShading=false;
                   // cube.material=cubeMaterialGShanding;
                   // torus.material=torusMaterialGShading;
                    //pyramid.material=pyramidMaterialGShading
                }
            });

            controlShading.add(view,'PhongShading').listen().onChange(function(value){
                if(value){
                    view.FlatShading=false;
                    view.GouraudShading=false;
                    cube.material=cubeMaterialPhongShading;
                    torus.material=torusMaterialPhongShading;
                    pyramid.material=pyramidMaterialPhongShading;
                }
            });
        
        }

        //Picking
        projector = new THREE.Projector();
        var vector;
        var ray;
        var intersects;
        var flag=false;
        renderer.domElement.addEventListener( 'mousedown', onMouseDown );// se maneja el evento del click

        function onMouseDown(event) {
            event.preventDefault();
            vector = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1,0.5 );
            projector.unprojectVector( vector, camera );
    
            ray = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );

            intersects = ray.intersectObjects( objects );    

            if ( intersects.length > 0 &&view.StopObjects) {
                intersects[0].object.callback();
            }
        }


        function render() {
            // Rotacion de los objetos
            if(!view.StopObjects){
                orbita_cube+=speeds.cubeSpeed;
                orbita_torus+=speeds.torusSpeed;
                orbita_pyramid+=speeds.pyramidSpeed;
                orbita_sphere+=speeds.sphereSpeed;
                
                cube.position.x=10*Math.cos(orbita_cube);
                cube.position.z=10*Math.sin(orbita_cube);

                torus.position.x=20*Math.cos(orbita_torus);
                torus.position.z=20*Math.sin(orbita_torus);

                sphere.position.x=30*Math.cos(orbita_sphere);
                sphere.position.z=30*Math.sin(orbita_sphere);

                pyramid.position.x=40*Math.cos(orbita_pyramid);
                pyramid.position.z=40*Math.sin(orbita_pyramid);
            }

            if(view.GouraudShading){
                rotate(cube,0.02);
                rotate(torus,0.04);
                rotate(sphere,0.03);
                rotate(pyramid,0.01);
            }

            if(view.PhongShading){
                controls.update();
            }

            if(rotateCube){//si el cubo fue el objeto en donde el usuario dio click entonces rotara sobre xyz
                rotate(cube,0.01);
            }
            if(rotateSphere){//si la esfera fue el objeto en donde el usuario dio click entonces rotara sobre xyz
                rotate(sphere,0.01);
            }
            if(rotatePyramid){//si la piramide fue el objeto en donde el usuario dio click entonces rotara sobre xyz
                rotate(pyramid,0.01);
            }
            if(rotateTorus){//si el toroide fue el objeto en donde el usuario dio click entonces rotara sobre xyz
                rotate(torus,0.01);
            }

            requestAnimationFrame(render);
            renderer.render(scene, camera);

        }

        function rotate(objects,rotacion){
            objects.rotation.x+=rotacion;
            objects.rotation.y+=rotacion;
            objects.rotation.z+=rotacion;
        }

        function initStats() {

            var stats = new Stats();

            stats.setMode(0); // 0: fps, 1: ms

            // Align top-left
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.left = '0px';
            stats.domElement.style.top = '0px';

            $("#Stats-output").append( stats.domElement );

            return stats;
        }


    });

</script>
</body>
</html>
