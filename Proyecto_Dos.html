<!DOCTYPE html>
<html>

<head>
    <title>Computer Graphics</title>
    <script type="text/javascript" src="lib_three/build/three.min.js"></script>
    <script type="text/javascript" src="lib_three/src/loaders/JSONLoader.js"> </script>
    <script type="text/javascript" src="lib_three/examples/js/controls/TrackballControls.js"> </script>
    
    <script type="text/javascript" src="jquery-1.9.0.js"></script>
    <script type="text/javascript" src="lib_three/examples/js/libs/dat.gui.min.js"></script>
    <script type="text/javascript" src="lib_three/examples/js/libs/stats.min.js"></script>
    <style>
        body{
            /* set margin to 0 and overflow to hidden, to go fullscreen */
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>

<div id="Stats-output"></div>
<!-- Div which will hold the Output -->
<div id="WebGL-output"></div>
<!-- Javascript code that runs our Three.js examples -->
<script type="text/javascript">

    // once everything is loaded, we run our Three.js stuff.
    $(function () {

        var stats = initStats();

        // create a scene, that will hold all our elements such as objects, cameras and lights.
        var scene = new THREE.Scene();

        // create a render and set the size
        var renderer = new THREE.WebGLRenderer();
        var orbita=0;
        
        var objects=new Array();

        renderer.setClearColorHex(0xCEE3F6, 1.0);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMapEnabled = true;


        // create the ground plane
        planeWidth=200;
        planeHeight=200;
        var planeGeometry = new THREE.PlaneGeometry(planeWidth,planeHeight,1,1);
        // PlaneGeometry(width, height, widthSegments, heightSegments) widthSegments y heightSegments son parametros opcionales y son 1 por defecto
        var planeMaterial =    new THREE.MeshLambertMaterial({color: 0xe0f8f1});
        var plane = new THREE.Mesh(planeGeometry,planeMaterial);
        plane.receiveShadow  = true;

        // rotacion y posicion del plano
        plane.rotation.x=-0.5*Math.PI;
        plane.position.x=5;
        plane.position.y=0
        plane.position.z=0
        // se añade el plano a la escena
        scene.add(plane);

        //Ejes auxiliares         
        var axes = new THREE.AxisHelper( 20 );
        scene.add(axes);
        //Cubo
        var cubeGeometry = new THREE.CubeGeometry(4,4,4);
        var cubeMaterialFlatShanding = new THREE.MeshLambertMaterial({color: 0xff0000,shading:THREE.FlatShading });
        var cubeMaterialGShading= new THREE.MeshLambertMaterial({color: 0xeeeeaa});//falta definir gourand shading
        var cubeMaterialPhongShading= new THREE.MeshLambertMaterial({color: 0xffff00});//falta definir phong shading
        var cube = new THREE.Mesh(cubeGeometry, cubeMaterialFlatShanding);
        // posicion del cubo
        cube.position.x=6;
        cube.position.y=7;
        cube.position.z=25;
        // se añade el cubo a la escena
        scene.add(cube);
        
        //Toroide
        var torusGeometry=new THREE.TorusGeometry(2,1,7,20,Math.Pi*2);
        // TorusGeometry(radius, tube, radialSegments, tubularSegments, arc) 
        var torusMaterial=new THREE.MeshLambertMaterial({color: 0xffff00,shading:THREE.FlatShading });// tipo de material del toroide
        var torusMaterialGShading=new THREE.MeshLambertMaterial({color: 0xeeeeaa});//falta
        var torusMaterialPhongShading=new THREE.MeshLambertMaterial({color: 0xffff00});//falta
        var torus=new THREE.Mesh(torusGeometry,torusMaterial);//se construye el toroide


        //posiciones del toroide 
        torus.position.x=-20;
        torus.position.y=10;
        torus.position.z=-20;
        scene.add(torus);//se añade el toroide a la escena


        var pyramidGeometry=new THREE.CylinderGeometry(0,5,8,4);
        /* CylinderGeometry(radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded) 
            height: altura de la piramide
            radiusSegments: numero de segmentos que se usara para formar las caras superior e inferior, 4 para que la base sea un cuadrado
            heightSegments 1 por defecto
            openEnded: indica si los extremos del cilindo estan abiertos(true) o cubiertos(false), false por defecto
        */
        
        var pyramidMaterial=new THREE.MeshLambertMaterial({color: 0x2ef72e,shading:THREE.FlatShading}); //tipo de material de la piramide
        var pyramidMaterialGShading=new THREE.MeshLambertMaterial({color: 0xffffff});//falta
        var pyramidMaterialPhongShading=new THREE.MeshLambertMaterial({color: 0xffee00});


        var pyramid=new THREE.Mesh(pyramidGeometry,pyramidMaterial);//se construye la piramide
        //posiciones de la piramide 
        pyramid.position.x=20;
        pyramid.position.y=12;
        pyramid.position.z=0;
        scene.add(pyramid); //se añade la piramide a la escena       
       
        var radius_sphera=3;//radio de la esfera
        var sphereGeometry = new THREE.SphereGeometry(radius_sphera,15,15);
        var sphereMaterial = new THREE.MeshLambertMaterial({color: 0x7777ff,shading:THREE.FlatShading });
        var sphereMaterialGShading=new THREE.MeshLambertMaterial({color: 0xeeeeaa});//falta
        var sphereMaterialPhongShading=new THREE.MeshLambertMaterial({color: 0xffee00});

        var sphere = new THREE.Mesh(sphereGeometry,sphereMaterial);
        // posicion de la esfera
        sphere.position.x=0;
        sphere.position.y=14;
        sphere.position.z=20;
        sphere.castShadow=true;
        // se añade la esfera a la escena
        scene.add(sphere);         
   

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000 );
        camera.position.x= -50;
        camera.position.y=  25; 
        camera.position.z= 30;
        camera.lookAt(scene.position);
        scene.add(camera);

        // add the output of the renderer to the html element
        $("#WebGL-output").append(renderer.domElement);
        
        
       var jsonLoader=new THREE.JSONLoader();

       jsonLoader.load("teapot.js", function(geometry) { 
                var material    = new THREE.MeshLambertMaterial({color: 0x660066},shading=THREE.FlatShading); 
                var mesh    = new THREE.Mesh( geometry, material ); 
                mesh.position.x= 0;
                mesh.position.y=4;
                mesh.position.z=0;
                mesh.scale.set(2,2,2);
                scene.add( mesh ); 
                //teapot = mesh; 
        });

        var spotLight1 = new THREE.SpotLight( 0xffffff );
        spotLight1.position.set( -window.innerWidth/2,window.innerHeight/2,20 );
        //spotLight.castShadow = true;
        scene.add( spotLight1 );
 
        var spotLight2 = new THREE.SpotLight( 0xffffff );
        spotLight2.position.set( -window.innerWidth/2, -window.innerHeight/2,20 );
        //spotLight.castShadow = true;
        scene.add( spotLight2 );
 
        var spotLight3 = new THREE.SpotLight( 0xffffff );
        spotLight3.position.set( window.innerWidth/2, window.innerHeight/2,20 );
        //spotLight.castShadow = true;
        scene.add( spotLight3 );
 
        var spotLight4 = new THREE.SpotLight( 0xffffff );
        spotLight4.position.set( window.innerWidth/2, -window.innerHeight/2,20 );
        //spotLight.castShadow = true;
        scene.add( spotLight4 );

        controls = new THREE.TrackballControls( camera, renderer.domElement );
        controls.rotateSpeed = 1.0;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.2;

        var gui=new dat.GUI();
        //controles de las velocidades de los objetos
        var controlSpeed;
        var speeds=new function(){
            this.cubeSpeed=0.01;
            this.torusSpeed=0.02;
            this.pyramidSpeed=0.02;
            this.sphereSpeed=0.02;
        }

        controlSpeed=gui.addFolder("Speeds of objects");
        controlSpeed.add(speeds,"cubeSpeed",0,0.5);
        controlSpeed.add(speeds,"torusSpeed",0.02,0.5);
        controlSpeed.add(speeds,"pyramidSpeed",0.01,0.5);
        controlSpeed.add(speeds,"sphereSpeed",0.02,0.5);
        var orbita_cube=0;
        var orbita_torus=0.02;
        var orbita_pyramid=0.01;
        var orbita_sphere=0.02;

        //control de los shading
        var view=this;
        view.FlatShading=true;
        view.GouraudShading=false;
        view.PhongShading=false;
        var controlShading=gui.addFolder("Shadings");
        controlShading.add(view,'FlatShading').listen().onChange(function(value){
            if(value){
                view.GouraudShading=false;
                view.PhongShading=false;
                cube.material=cubeMaterialFlatShanding;
                torus.material=torusMaterial;
                pyramid.material=pyramidMaterial;
                sphere.material=sphereMaterial;
            }
        });

        controlShading.add(view,'GouraudShading').listen().onChange(function(value){
            if(value){
                view.FlatShading=false;
                view.PhongShading=false;
             //   cube.material=cubeMaterialGShanding;
               // torus.material=torusMaterialGShading;
                //pyramid.material=pyramidMaterialGShading;
               // sphere.material=sphereMaterialGShading;

            }
        });


        controlShading.add(view,'PhongShading').listen().onChange(function(value){
            if(value){
                view.FlatShading=false;
                view.GouraudShading=false;

                cube.material=cubeMaterialPhongShading;
                torus.material=torusMaterialPhongShading;
                pyramid.material=pyramidMaterialPhongShading;
                sphere.material=sphereMaterialPhongShading;
            }
        });
        
        var rotaciones=[0.02,0.04,0.03,0.01];

        controlShading.open();


        render();
       

        function render() {

            // render using requestAnimationFrame
            orbita+=0.01;
            orbita_cube+=speeds.cubeSpeed;
            orbita_torus+=speeds.torusSpeed;
            orbita_pyramid+=speeds.pyramidSpeed;
            orbita_sphere+=speeds.sphereSpeed;
            
            cube.position.x=10*Math.cos(orbita_cube);
            cube.position.z=10*Math.sin(orbita_cube);

            torus.position.x=20*Math.cos(orbita_torus);
            torus.position.z=20*Math.sin(orbita_torus);

            sphere.position.x=30*Math.cos(orbita_sphere);
            sphere.position.z=30*Math.sin(orbita_sphere);

            pyramid.position.x=40*Math.cos(orbita_pyramid);
            pyramid.position.z=40*Math.sin(orbita_pyramid);
            
            if(view.GouraudShading){

                cube.rotation.x+=rotaciones[0];
                cube.rotation.y+=rotaciones[0];
                cube.rotation.z+=rotaciones[0];

                torus.rotation.x+=rotaciones[1];
                torus.rotation.y+=rotaciones[1];
                torus.rotation.z+=rotaciones[1];

                sphere.rotation.x+=rotaciones[2];
                sphere.rotation.y+=rotaciones[2];
                sphere.rotation.z+=rotaciones[2];
               

                pyramid.rotation.x+=rotaciones[3];
                pyramid.rotation.y+=rotaciones[3];
                pyramid.rotation.z+=rotaciones[3];
            }


            requestAnimationFrame(render);
            controls.update();
            renderer.render(scene, camera);

        }




        function initStats() {

            var stats = new Stats();

            stats.setMode(0); // 0: fps, 1: ms

            // Align top-left
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.left = '0px';
            stats.domElement.style.top = '0px';

            $("#Stats-output").append( stats.domElement );

            return stats;
        }
    });

</script>
</body>
</html>
